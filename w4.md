<br/>

## 4주차 과제: 제어문 
자바가 제공하는 제어문을 학습하세요.
*** 
### 학습할 것 (필수)
- 선택문
- 반복문
### 과제 (옵션)
- 과제 0. JUnit 5 학습하세요.
- 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.
- 과제 2. LinkedList를 구현하세요.
- 과제 3. Stack을 구현하세요.
- 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.
- 과제 5. Queue를 구현하세요.
***
<br/><br/><br/><br/>

# 선택문
<br/><br/><br/><br/>

# 반복문
<br/><br/><br/><br/> 

# 과제 0. JUnit 5 학습하세요.
<br/><br/><br/><br/>

# 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.
<pre>
GitHub gitHub = GitHub.connect();
GHRepository repository = gitHub.getRepository(repositoryName);

HashMap❮String, int[]❯ userMap = new HashMap❮❯();
for(int i=1; i<=18; i++) {
    GHIssue issue = repository.getIssue(i);
    List❮GHIssueComment❯ comments = issue.getComments();
    for (GHIssueComment comment : comments) {
        GHUser user = comment.getUser();
        int[] weeks;
        if(userMap.containsKey(user.getLogin())) {
            weeks = userMap.get(user.getLogin());
        } else {
            weeks = new int[18];
        }
        weeks[i-1] = 1;
        userMap.put(user.getLogin(), weeks);
    }
}

for (String userName : userMap.keySet()) {
    System.out.print(userName + " ");
    int[] weeks = userMap.get(userName);
    System.out.print(Arrays.toString(weeks) + " ");
    System.out.println(String.format("%.2f", ((float) Arrays.stream(weeks).sum()/18)*100) + " %");
}
</pre>
<br/><br/><br/><br/>

# 과제 2. LinkedList를 구현하세요.
<pre>
public class ListNode {

    int value;
    ListNode next;

    public ListNode(int value) {
        this.value = value;
        this.next = null;
    }

    public ListNode add(ListNode head, ListNode nodeToAdd, int position) {
        ListNode current = head;
        if(position == 0) {
            nodeToAdd.next = current;
            return nodeToAdd;
        }
        for(int index=0; index<(position-1); index++) {
            current = current.next;
        }
        ListNode nodeToAddNext = current.next;
        nodeToAdd.next = nodeToAddNext;
        current.next = nodeToAdd;
        return head;
    }

    public ListNode remove(ListNode head, int positionToRemove) {
        ListNode current = head;
        if(positionToRemove == 0) {
            return head.next;
        }
        for(int index=0; index<(positionToRemove-1); index++) {
            current = current.next;
        }
        ListNode nodeToRemove = current.next;
        current.next = nodeToRemove.next;
        return head;
    }

    public boolean contains(ListNode head, ListNode nodeToCheck) {
        ListNode current = head;
        while(current != null) {
            if(current == nodeToCheck) {
                return true;
            }
            current = current.next;
        }
        return false;
    }

}
</pre>
<pre>
class ListNodeTest {

    ListNode head;

    @BeforeEach
    void addListNode() {
        head = new ListNode(2);
        head = head.add(head, new ListNode(5), 0);
        head = head.add(head, new ListNode(7), 2);
        assertEquals(5, head.value);
        assertEquals(2, head.next.value);
        assertEquals(7, head.next.next.value);
        head = head.add(head, new ListNode(9), 1);
        assertEquals(5, head.value);
        assertEquals(9, head.next.value);
        assertEquals(2, head.next.next.value);
        assertEquals(7, head.next.next.next.value);
    }

    @Test
    void removeListNode() {
        head = head.remove(head, 0);
        assertEquals(9, head.value);
        assertEquals(2, head.next.value);
        assertEquals(7, head.next.next.value);
        head = head.remove(head, 2);
        assertEquals(9, head.value);
        assertEquals(2, head.next.value);
    }

    @Test
    void containsListNode() {
        ListNode nodeToCheck_true = new ListNode(1);
        head = head.add(head, nodeToCheck_true, 1);
        assertTrue(head.contains(head, nodeToCheck_true));
        ListNode nodeToCheck_false = new ListNode(5);
        assertFalse(head.contains(head, nodeToCheck_false));
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 3. Stack을 구현하세요.
<pre>
public class Stack {

    int[] stack;
    int size;
    int top;

    public Stack(int size) {
        top = -1;
        stack = new int[size];
        this.size = size;
    }

    public int peek() {
        return stack[top];
    }

    public int pop() {
        int result = stack[top];
        stack[top] = 0;
        top--;
        return result;
    }

    public void push(int value) {
        stack[++top] = value;
    }

}
</pre>
<pre>
class StackTest {

    @Test
    void pushPop() {
        Stack stack = new Stack(5);
        stack.push(2);
        stack.push(1);
        stack.push(5);
        assertEquals(2, stack.top);
        assertEquals(5, stack.pop());
        assertEquals(1, stack.pop());
        assertEquals(0, stack.top);
        assertEquals(2, stack.pop());
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            stack.pop();
        });
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.
<pre>
public class ListNodeStack {

    ListNode head;

    public int pop() {
        if(head == null)
            throw new EmptyStackException();
        int value = head.value;
        ListNode removed = head.remove(head, 0);
        head = removed;
        return value;
    }

    public void push(int value) {
        if(head == null) {
            head = new ListNode(value);
        } else {
            ListNode nodeToPush = new ListNode(value);
            head = head.add(head, nodeToPush, 0);
        }
    }

}
</pre>
<pre>
class ListNodeStackTest {

    @Test
    void pushPopListNodeStack() {
        ListNodeStack listNodeStack = new ListNodeStack();
        assertThrows(EmptyStackException.class, () -> {
            listNodeStack.pop();
        });
        listNodeStack.push(5);
        listNodeStack.push(1);
        listNodeStack.push(2);
        assertEquals(2, listNodeStack.pop());
        assertEquals(1, listNodeStack.pop());
        assertEquals(5, listNodeStack.pop());
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 5. Queue를 구현하세요.
<pre>
public class Queue {

    int[] queue;
    int size;
    int head;
    int tail;

    public Queue(int size) {
        queue = new int[size];
        this.size = size;
    }

    public void enqueue(int value) {
        if(isFull())
            grow();
        queue[tail] = value;
        tail++;
    }

    public int dequeue() {
        int result = queue[head];
        head++;
        if(head >= (size / 2))
            optimize();
        return result;
    }

    private boolean isFull() {
        return (tail == size) ? true : false;
    }

    private void grow() {
        size *= 2;
        copyArray(size);
    }

    private void optimize() {
        if((tail - head) < (size / 2))
            size /= 2;
        copyArray(size);
    }

    private void copyArray(int size) {
        int[] temp = queue;
        queue = new int[size];
        for(int i=0; i<(tail-head); i++) {
            queue[i] = temp[i+head];
        }
        tail -= head;
        head = 0;
    }

}
</pre>
<pre>
class QueueTest {

    @Test
    void enqueueDequeue() {
        Queue queue = new Queue(3);
        queue.enqueue(2);
        queue.enqueue(5);
        queue.enqueue(7);
        queue.enqueue(9);
        assertEquals(6, queue.size);
        assertEquals(2, queue.dequeue());
        assertEquals(5, queue.dequeue());
        assertEquals(7, queue.dequeue());
        assertEquals(0, queue.head);
        assertEquals(1, queue.tail);
        queue.enqueue(9);
        queue.enqueue(1);
        queue.enqueue(2 );
        assertEquals(6, queue.size);
        assertEquals(0, queue.head);
        assertEquals(4, queue.tail);
        queue.enqueue(6);
        queue.enqueue(8);
        queue.enqueue(3);
        assertEquals(12, queue.size);
        assertEquals(9, queue.dequeue());
        assertEquals(9, queue.dequeue());
        assertEquals(1, queue.dequeue());
        assertEquals(2, queue.dequeue());
        assertEquals(6, queue.dequeue());
        assertEquals(8, queue.dequeue());
        assertEquals(0, queue.head);
        assertEquals(1, queue.tail);
        assertEquals(6, queue.size);
    }

}
</pre>
<br/><br/><br/><br/>