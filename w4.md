<br/>

## 4주차 과제: 제어문 
자바가 제공하는 제어문을 학습하세요.
*** 
### 학습할 것 (필수)
- 선택문
- 반복문
### 과제 (옵션)
- 과제 0. JUnit 5 학습하세요.
- 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.
- 과제 2. LinkedList를 구현하세요.
- 과제 3. Stack을 구현하세요.
- 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.
- 과제 5. Queue를 구현하세요.
    - 배열을 사용해서 한번.
    - ListNode를 사용해서 한번. 
***
<br/><br/><br/><br/>

# 선택문 (decision-making statements) 
- if-then, if-then-else, switch
<br/>

## if-then
if 조건문이 true일 경우에만 실행문을 실행한다.
<pre>
if(조건문) {
    실행문     // 조건문이 true일 경우에 실행된다. 
}
</pre>
예를 들어, 아래의 코드처럼 자전거가 달리고 있을 때에만 자전거의 속도를 낮춘다. <br/>
자전거가 달리고 있지 않은 상태이면(false) 실행문이 실행되지 않고 건너뛴다. 
<pre>
if(isMoving) {
    currentSpeed--;    // 자전거가 움직이고 있을 때에만 실행된다. 
}
</pre>
실행문이 하나일 경우에는 괄호를 생략할 수도 있다.
<pre>
if(isMoving)
    currentSpeed--;    // 자전거가 움직이고 있을 때에만 실행된다. 
</pre><br/>

## if-then-else
위의 if 문에서 else를 붙이면 if 조건문이 false일 경우에 실행할 실행문도 추가할 수 있다.
<pre>
if(조건문) {
    실행문      // 조건문이 true일 경우에 실행된다.
} else { 
    실행문      // 조건문이 false일 경우에 실행된다. 
}
</pre>
자전거가 달리고 있는 상태이면 속도를 낮추고, 달리고 있지 않은 상태이면 에러 메세지를 출력해보자. 
<pre>
if(isMoving) {
    currentSpeed--;     // 자전거가 움직이고 있을 때에만 실행된다. 
} else {
    System.err.println("자전거는 이미 멈춰있어!!");    // 자전거가 멈춰있는 상태이면 실행된다. 
}
</pre><br/>

## switch

<br/><br/><br/><br/>

# 반복문 (looping statements)
- for, while, do-while
<br/><br/><br/><br/> 

# 과제 1. live-study 대시 보드를 만드는 코드를 작성하세요.
<pre>
GitHub gitHub = GitHub.connect();
GHRepository repository = gitHub.getRepository(repositoryName);

HashMap❮String, int[]❯ userMap = new HashMap❮❯();
for(int i=1; i<=18; i++) {
    GHIssue issue = repository.getIssue(i);
    List❮GHIssueComment❯ comments = issue.getComments();
    for (GHIssueComment comment : comments) {
        GHUser user = comment.getUser();
        int[] weeks;
        if(userMap.containsKey(user.getLogin())) {
            weeks = userMap.get(user.getLogin());
        } else {
            weeks = new int[18];
        }
        weeks[i-1] = 1;
        userMap.put(user.getLogin(), weeks);
    }
}

for (String userName : userMap.keySet()) {
    System.out.print(userName + " ");
    int[] weeks = userMap.get(userName);
    System.out.print(Arrays.toString(weeks) + " ");
    System.out.println(String.format("%.2f", ((float) Arrays.stream(weeks).sum()/18)*100) + " %");
}
</pre>
<br/><br/><br/><br/>

# 과제 2. LinkedList를 구현하세요.
<pre>
public class ListNode {

    int value;
    ListNode next;

    public ListNode(int value) {
        this.value = value;
        this.next = null;
    }

    public ListNode add(ListNode head, ListNode nodeToAdd, int position) {
        ListNode current = head;
        if(position == 0) {
            nodeToAdd.next = current;
            return nodeToAdd;
        }
        for(int index=0; index<(position-1); index++) {
            current = current.next;
        }
        ListNode nodeToAddNext = current.next;
        nodeToAdd.next = nodeToAddNext;
        current.next = nodeToAdd;
        return head;
    }

    public ListNode remove(ListNode head, int positionToRemove) {
        ListNode current = head;
        if(positionToRemove == 0) {
            return head.next;
        }
        for(int index=0; index<(positionToRemove-1); index++) {
            current = current.next;
        }
        ListNode nodeToRemove = current.next;
        current.next = nodeToRemove.next;
        return head;
    }

    public boolean contains(ListNode head, ListNode nodeToCheck) {
        ListNode current = head;
        while(current != null) {
            if(current == nodeToCheck) {
                return true;
            }
            current = current.next;
        }
        return false;
    }

}
</pre>
<pre>
class ListNodeTest {

    ListNode head;

    @BeforeEach
    void addListNode() {
        head = new ListNode(2);
        head = head.add(head, new ListNode(5), 0);
        head = head.add(head, new ListNode(7), 2);
        assertEquals(5, head.value);
        assertEquals(2, head.next.value);
        assertEquals(7, head.next.next.value);
        head = head.add(head, new ListNode(9), 1);
        assertEquals(5, head.value);
        assertEquals(9, head.next.value);
        assertEquals(2, head.next.next.value);
        assertEquals(7, head.next.next.next.value);
    }

    @Test
    void removeListNode() {
        head = head.remove(head, 0);
        assertEquals(9, head.value);
        assertEquals(2, head.next.value);
        assertEquals(7, head.next.next.value);
        head = head.remove(head, 2);
        assertEquals(9, head.value);
        assertEquals(2, head.next.value);
    }

    @Test
    void containsListNode() {
        ListNode nodeToCheck_true = new ListNode(1);
        head = head.add(head, nodeToCheck_true, 1);
        assertTrue(head.contains(head, nodeToCheck_true));
        ListNode nodeToCheck_false = new ListNode(5);
        assertFalse(head.contains(head, nodeToCheck_false));
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 3. Stack을 구현하세요.
<pre>
public class Stack {

    int[] stack;
    int size;
    int top;

    public Stack(int size) {
        top = -1;
        stack = new int[size];
        this.size = size;
    }

    public int peek() {
        return stack[top];
    }

    public int pop() {
        int result = stack[top];
        stack[top] = 0;
        top--;
        return result;
    }

    public void push(int value) {
        stack[++top] = value;
    }

}
</pre>
<pre>
class StackTest {

    @Test
    void pushPop() {
        Stack stack = new Stack(5);
        stack.push(2);
        stack.push(1);
        stack.push(5);
        assertEquals(2, stack.top);
        assertEquals(5, stack.pop());
        assertEquals(1, stack.pop());
        assertEquals(0, stack.top);
        assertEquals(2, stack.pop());
        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {
            stack.pop();
        });
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 4. 앞서 만든 ListNode를 사용해서 Stack을 구현하세요.
<pre>
public class ListNodeStack {

    ListNode head;

    public int pop() {
        if(head == null)
            throw new EmptyStackException();
        int value = head.value;
        ListNode removed = head.remove(head, 0);
        head = removed;
        return value;
    }

    public void push(int value) {
        if(head == null) {
            head = new ListNode(value);
        } else {
            ListNode nodeToPush = new ListNode(value);
            head = head.add(head, nodeToPush, 0);
        }
    }

}
</pre>
<pre>
class ListNodeStackTest {

    @Test
    void pushPopListNodeStack() {
        ListNodeStack listNodeStack = new ListNodeStack();
        assertThrows(EmptyStackException.class, () -> {
            listNodeStack.pop();
        });
        listNodeStack.push(5);
        listNodeStack.push(1);
        listNodeStack.push(2);
        assertEquals(2, listNodeStack.pop());
        assertEquals(1, listNodeStack.pop());
        assertEquals(5, listNodeStack.pop());
    }

}
</pre>
<br/><br/><br/><br/>

# 과제 5. Queue를 구현하세요.
- 배열을 사용해서 한번. 
<pre>
public class Queue {

    int[] queue;
    int size;
    int head;
    int tail;

    public Queue(int size) {
        queue = new int[size];
        this.size = size;
    }

    public void enqueue(int value) {
        if(isFull())
            grow();
        queue[tail] = value;
        tail++;
    }

    public int dequeue() {
        int result = queue[head];
        head++;
        if(head >= (size / 2))
            optimize();
        return result;
    }

    private boolean isFull() {
        return (tail == size) ? true : false;
    }

    private void grow() {
        size *= 2;
        copyArray(size);
    }

    private void optimize() {
        if((tail - head) < (size / 2))
            size /= 2;
        copyArray(size);
    }

    private void copyArray(int size) {
        int[] temp = queue;
        queue = new int[size];
        for(int i=0; i<(tail-head); i++) {
            queue[i] = temp[i+head];
        }
        tail -= head;
        head = 0;
    }

}
</pre>
<pre>
class QueueTest {

    @Test
    void enqueueDequeue() {
        Queue queue = new Queue(3);
        queue.enqueue(2);
        queue.enqueue(5);
        queue.enqueue(7);
        queue.enqueue(9);
        assertEquals(6, queue.size);
        assertEquals(2, queue.dequeue());
        assertEquals(5, queue.dequeue());
        assertEquals(7, queue.dequeue());
        assertEquals(0, queue.head);
        assertEquals(1, queue.tail);
        queue.enqueue(9);
        queue.enqueue(1);
        queue.enqueue(2 );
        assertEquals(6, queue.size);
        assertEquals(0, queue.head);
        assertEquals(4, queue.tail);
        queue.enqueue(6);
        queue.enqueue(8);
        queue.enqueue(3);
        assertEquals(12, queue.size);
        assertEquals(9, queue.dequeue());
        assertEquals(9, queue.dequeue());
        assertEquals(1, queue.dequeue());
        assertEquals(2, queue.dequeue());
        assertEquals(6, queue.dequeue());
        assertEquals(8, queue.dequeue());
        assertEquals(0, queue.head);
        assertEquals(1, queue.tail);
        assertEquals(6, queue.size);
    }

}
</pre><br/>
- ListNode를 사용해서 한번.
<pre>
public class ListNodeQueue {

    ListNode head;

    public void enqueue(int value) {
        if(head == null) {
            head = new ListNode(value);
        } else {
            ListNode current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = new ListNode(value);
        }
    }

    public int dequeue() {
        if(head == null)
            throw new NoSuchElementException();
        int value = head.value;
        head = head.remove(head, 0);
        return value;
    }

}
</pre>
<pre>
class ListNodeQueueTest {

    @Test
    void enDeListNodeQueque() {
        ListNodeQueue listNodeQueue = new ListNodeQueue();
        assertThrows(NoSuchElementException.class, () -> {
            listNodeQueue.dequeue();
        });
        listNodeQueue.enqueue(9);
        listNodeQueue.enqueue(5);
        listNodeQueue.enqueue(7);
        assertEquals(9, listNodeQueue.dequeue());
        assertEquals(5, listNodeQueue.dequeue());
        assertEquals(7, listNodeQueue.dequeue());
    }

}
</pre>
<br/><br/><br/><br/>