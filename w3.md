<br/>

## 3주차 과제: 연산자
자바가 제공하는 다양한 연산자를 학습하세요.
*** 
### 학습할 것
- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자
- instanceof
- assignment(=) operator
- 화살표(->) 연산자
- 3항 연산자
- 연산자 우선 순위
- (optional) Java 13. switch operator
***
<br/><br/><br/><br/>

# 산술 연산자 (Arithmetic operator)
- 수학적 계산에 사용되는 연산자.
- 두 개의 피연산자를 가지는 이항 연산자. 
- 피연산자들의 결합 방향은 왼쪽에서 오른쪽.

|산술 연산자|설명|
|:---:|---|
|+|더하기|
|-|빼기|
|*|곱하기|
|/|나누기|
|%|나머지|

<pre>
class ArithmeticDemo {
    public static void main (String[] args) {
        int result = 1 + 2;
        System.out.println("1 + 2 = " + result);                  // 3
        int original_result = result;

        result = result - 1;
        System.out.println(original_result + " - 1 = " + result); // 2
        original_result = result;

        result = result * 2;
        System.out.println(original_result + " * 2 = " + result); // 4
        original_result = result;

        result = result / 2;
        System.out.println(original_result + " / 2 = " + result); // 2
        original_result = result;

        result = result + 8;
        System.out.println(original_result + " + 8 = " + result); // 10
        original_result = result;

        result = result % 7;
        System.out.println(original_result + " % 7 = " + result); // 3
    }
}
</pre>
<pre>
This program prints the following:
        1 + 2 = 3
        3 - 1 = 2
        2 * 2 = 4
        4 / 2 = 2
        2 + 8 = 10
        10 % 7 = 3
</pre>
<br/><br/>

# 단항 연산자 (Unary Operator)
|단항 연산자|설명|
|:---:|---|
|+|양수|
|-|음수|
|++|1 증가|
|--|1 감소|
|!|반대 (논리 연산자에도 해당.)|

<pre>
class UnaryDemo {
    public static void main(String[] args) {
        int result = +1;
        System.out.println(result);     // 1

        result--;
        System.out.println(result);     // 0

        result++;
        System.out.println(result);     // 1

        result = -result;
        System.out.println(result);     // -1

        boolean success = false;
        System.out.println(success);    // false
        System.out.println(!success);   // true
    }
}
</pre>
<br/><br/><br/><br/>

# 비트 연산자 (Bitwise operator)
- 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자.

|비트 연산자|설명|
|:---:|---|
|&|대응되는 비트가 모두 1이면 1을 반환. (비트 AND 연산)|
|\\||대응되는 비트 중에서 하나라도 1이면 1을 반환. (비트 OR 연산)|
|^|대응되는 비트가 서로 다르면 1을 반환. (비트 XOR 연산)|
|~|비트를 1이면 0, 0이면 1로 반전. (비트 NOT 연산, 1의 보수)|
|<<|명시된 수만큼 비트들을 모두 왼쪽으로 이동. (Left shift 연산)|
|>>|부호를 유지하고 지정된 수만큼 모두 오른쪽으로 이동. (Right shift 연산)|
|>>>|명시된 수만큼 비트들을 모두 오른쪽으로 이동, 새로운 비트는 0으로 채움. (Unsigned right shift 연산)|  

### * 비트 보수 연산 (~)
<pre>
byte b = ~12;                   // ~00001100
System.out.println(b);          // -13
System.out.println(String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0')); // 11110011

byte flags = 12;                // 00001100
byte f = 8;                     // 00001000
flags = (byte) (flags & ~f);    // 00001100 & ~00001000
System.out.println(String.format("%8s", Integer.toBinaryString(flags & 0xFF)).replace(' ', '0')); // 00000100
</pre>

### * 비트 AND 연산 (&)
<pre>
10 & 7                          // 00001010 & 00000111 => 00000010 또는 2 
if ((flags & f) != 0)           // 플래그 값들(flags) 중에서 특정 플래그 값 f가 의도대로 세팅되어 있는지 확인. 
</pre>

### * 비트 OR 연산 (|)
<pre>
10 | 7                          // 00001010 | 00000111 => 00001111 또는 15 
flags = flags | f;              // 플래그 값들(flags) 중에서 특정 플래그 값 f를 세팅. (f 플래값 위치에 1이 있다.)
</pre>

### * 비트 XOR 연산 (^)
<pre>
10 ^ 7                          // 00001010 ^ 00000111 => 00001101 or 13
</pre>

### * Left shift (<<)
<pre>
10 << 1                         // 0b00001010 << 1 = 00010100 = 20 = 10*2
7 << 3                          // 0b00000111 << 3 = 00111000 = 56 = 7*8
-1 << 2                         // 0xFFFFFFFF << 2 = 0xFFFFFFFC = -4 = -1*4
                                // 0xFFFF_FFFC == 0b1111_1111_1111_1111_1111_1111_1111_1100
</pre>

### * Right shift (>>)
<pre>
10 >> 1                         // 00001010 >> 1 = 00000101 = 5 = 10/2
27 >> 3                         // 00011011 >> 3 = 00000011 = 3 = 27/8
-50 >> 2                        // 11001110 >> 2 = 11110011 = -13 != -50/4
</pre>

### * Unsigned right shift (>>>)
<pre>
0xff >>> 4                      // 11111111 >>> 4 = 00001111 = 15 = 255/16 
-50 >>> 2                       // 0xFFFFFFCE >>> 2 = 0x3FFFFFF3 = 1073741811
</pre>
<br/><br/><br/><br/>

# 관계 연산자 (Relational operator, (비교 연산자, Comparison operator))
- 두 피연산자의 상대적인 크기를 판단하는 연산자.
- 왼쪽의 피연산자와 오른쪽의 피연산자를 비교하여, 어느 쪽이 더 큰지, 작은지, 또는 서로 같은지를 판단.
- 결합방향은 왼쪽에서 오른쪽.

|관계 연산자|설명|
|:---:|---|
|==|같으면 true.|
|!=|다르면 true.|
|>|왼쪽이 크면 true.|
|>=|왼쪽이 오른쪽보다 더 크거나 같으면 true.|
|<|오른쪽이 크면 true.|
|<=|오른쪽이 왼쪽보다 더 크거나 같으면 true.|

<pre>
char ch1 = 'a', ch2 = 'A';

System.out.println(ch1 == ch2);     // false
System.out.println(ch1 > ch2);      // true
</pre>
<br/><br/><br/><br/>

# 논리 연산자 (Logical operator)
- 논리식으로 true와 false를 판단.

|논리 연산자|설명|
|:---:|---|
|&&|논리식이 모두 참이면 true. (논리 AND 연산)|
|\\|\\||논리식 중에 하나라도 참이면 true. (논리 OR 연산)|
|!|논리식이 true이면 false, false이면 true. (논리 NOT 연산)|

<pre>
class ComparisonDemo {
    public static void main(String[] args){
        int value1 = 1;
        int value2 = 2;
        if(value1 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}
</pre>
<pre>
Output:
    value1 != value2
    value1 <  value2
    value1 <= value2
</pre>

<br/><br/><br/><br/>

# instanceof
- 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환. 
- 해당 객체가 어떤 클래스(부모 클래스 포함)나 인터페이스로부터 생성되었는지 판별.
<pre>
class InstanceofDemo {
    public static void main(String[] args) {

        Parent obj1 = new Parent();
        Parent obj2 = new Child();

        System.out.println("obj1 instanceof Parent: "
            + (obj1 instanceof Parent));
        System.out.println("obj1 instanceof Child: "
            + (obj1 instanceof Child));
        System.out.println("obj1 instanceof MyInterface: "
            + (obj1 instanceof MyInterface));
        System.out.println("obj2 instanceof Parent: "
            + (obj2 instanceof Parent));
        System.out.println("obj2 instanceof Child: "
            + (obj2 instanceof Child));
        System.out.println("obj2 instanceof MyInterface: "
            + (obj2 instanceof MyInterface));
    }
}

class Parent {}
class Child extends Parent implements MyInterface {}
interface MyInterface {}
</pre>
<pre>
Output:
    obj1 instanceof Parent: true
    obj1 instanceof Child: false
    obj1 instanceof MyInterface: false
    obj2 instanceof Parent: true
    obj2 instanceof Child: true
    obj2 instanceof MyInterface: true
</pre>
<br/><br/><br/><br/>

# assignment(=) operator
- 오른쪽의 값을 왼쪽 피연산자에 할당.
<pre>
int cadence = 0;
int speed = 0;
int gear = 1;
</pre>
- 또는, 객체 참조를 할당하기 위해 사용.
<pre>
Point originOne = new Point(23, 94);
Rectangle rectOne = new Rectangle(originOne, 100, 200);
Rectangle rectTwo = new Rectangle(50, 100);
</pre>
- 'a = b = c'의 경우, 오른쪽에서 왼쪽으로 수행. 'a = (b = c)'.
- 5개의 산술 연산자, 6개의 비트 및 Shift 연산자와 결합해서 사용할 수 있음.
<pre>
+=      -=      *=      /=      %=              // 산술 연산자와 결합해서 사용.
&=      |=      ^=                              // 비트 연산자와 결합해서 사용.
<<=     >>=     >>>=                            // Shift 연산자와 결합해서 사용.
</pre>
<br/><br/><br/><br/>

# 화살표(->) 연산자
- 자바 8 이상의 람다식에서 사용.
- 화살표 왼쪽에 인자, 오른쪽에 실제 표현식을 쓴다. 
<pre>
(매개변수, ...) -> { 실행문 ... }
</pre>
<br/><br/><br/><br/>

# 3항 연산자 (Ternary operator)
<br/><br/><br/><br/>

# 연산자 우선 순위
<br/><br/><br/><br/>

# (optional) Java 13. switch operator
<br/><br/><br/><br/>

###### 출처: 
http://www.tcpschool.com/java/java_operator_arithmetic <br/>
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html <br/>
https://stackoverflow.com/questions/12310017/how-to-convert-a-byte-to-its-binary-string-representation <br/>
<br/><br/><br/><br/>