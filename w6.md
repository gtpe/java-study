<br/>

## 6주차 과제: 상속 
자바의 상속에 대해 학습하세요.
*** 
### 학습할 것 (필수)
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스
***
<br/><br/><br/><br/>

# 자바 상속의 특징
어떠한 객체(부모)의 기능을 그대로 물려받으면서 새로운 기능을 추가한 객체(자식)를 만드는 것이다.<br/>
부모를 고치지 않고 부모의 기능을 재사용하면서 새로운 기능을 추가하고 싶을 때<br/>
부모를 상속 받는 자식 객체를 만들어서 메소드를 오버라이딩하거나 새로운 기능을 추가하여 사용한다. <br/>
<pre>
class [자식 클래스] extends [부모 클래스] {
}
</pre>
<pre>
public class Employee {

    public static int base = 10000;

    int salary() {
        return base;
    }

}

public class Manager extends Employee {

    int salary() {
        return base + 20000;
    }

}

public class Clerk extends Employee {

    int salary() {
        return base + 10000;
    }
    
}

public class Main {

    static void printSalary(Employee e) {
        System.out.println(e.salary());
    }

    public static void main(String[] args) {
        Employee employee_1 = new Manager();
        System.out.print("Manager's salary: ");
        printSalary(employee_1);
        // 출력 결과: Manager's salary: 30000

        Employee employee_2 = new Clerk();
        System.out.print("Clerk's salary: ");
        printSalary(employee_2);
        // 출력 결과: Clerk's salary: 20000
    }

}
</pre>
<br/><br/><br/><br/>

# super 키워드
상속관계에서 자식이 부모의 필드나 메소드를 호출할 때 사용한다. <br/>
<pre>
class A {
    int i = 1; 
    int f() { return i; } 
}
class B extends A { 
    int i;
    int f() {
        i = super.i + 1;        // 부모의 i 값을 가져와서 더한다.
        return super.f() + i;   // 부모의 f()를 호출하여 더한다. 
    } 
}
</pre>
https://docs.oracle.com/javase/tutorial/java/IandI/super.html <br/>
<br/><br/><br/><br/>

# 메소드 오버라이딩
<pre>
class A {
    int i = 1;    
    int f() { return i; }
    static char g() { return 'A'; }
}

class B extends A {
    int i = 2;
    int f() { return -i; }
    static char g() { return 'B'; }
}

public class OverrideTest {
    public static void main(String args[]) {
        B b = new B();  
        System.out.println(b.i);        // 출력 결과: 2
        System.out.println(b.f());      // 출력 결과: -2
        System.out.println(b.g());      // 출력 결과: B
        System.out.println(B.g());      // 출력 결과: B
        
        A a = (A)b; 
        System.out.println(a.i);        // 출력 결과: 1
        System.out.println(a.f());      // 출력 결과: -2
        System.out.println(a.g());      // 출력 결과: A
        System.out.println(A.g());      // 출력 결과: A
    } 
}
</pre>
<br/><br/><br/><br/>

# 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/ <br/>
https://stackoverflow.com/questions/4343247/what-is-dynamic-method-dispatch-and-how-does-it-relate-to-inheritance <br/>
## 더블 디스패치 (Double Dispatch)
<br/><br/><br/><br/>

# 추상 클래스
https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html <br/>
<br/><br/><br/><br/>

# final 키워드
https://docs.oracle.com/javase/tutorial/java/IandI/final.html <br/>
<br/><br/><br/><br/>

# Object 클래스
https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html <br/>
<br/><br/><br/><br/>
